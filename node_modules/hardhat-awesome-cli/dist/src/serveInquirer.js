"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const inquirer_1 = __importDefault(require("inquirer"));
const buildEnv_1 = __importStar(require("./buildEnv"));
const buildExcludedFile_1 = require("./buildExcludedFile");
const buildFilesList_1 = require("./buildFilesList");
const buildFoundrySetting_1 = __importDefault(require("./buildFoundrySetting"));
const buildMockContracts_1 = __importStar(require("./buildMockContracts"));
const buildNetworks_1 = require("./buildNetworks");
const buildWorkflows_1 = __importStar(require("./buildWorkflows"));
const config_1 = require("./config");
const mockContracts_1 = __importDefault(require("./mockContracts"));
const packageInstaller_1 = __importDefault(require("./packageInstaller"));
const utils_1 = require("./utils");
const serveNetworkSelector = async (env, command, firstCommand, GetAccountBalance, ServeEnvBuilder, noLocalNetwork) => {
    const ActivatedChainList = await (0, buildFilesList_1.buildActivatedChainList)();
    const BuildFullChainList = config_1.DefaultChainList;
    const activatedChainList = [];
    ActivatedChainList.map((chain) => {
        if (noLocalNetwork && chain.chainName !== 'hardhat')
            activatedChainList.push(chain.name);
        else if (!noLocalNetwork)
            activatedChainList.push(chain.name);
    });
    if (activatedChainList.length === 0) {
        const addHardhat = BuildFullChainList.find((basicChain) => basicChain.chainName === 'hardhat');
        const addHardhatLocalhost = BuildFullChainList.find((basicChain) => basicChain.chainName === 'localhost');
        if (addHardhat) {
            ActivatedChainList.push(addHardhat);
            activatedChainList.push(addHardhat.name);
        }
        if (addHardhatLocalhost) {
            ActivatedChainList.push(addHardhatLocalhost);
            activatedChainList.push(addHardhatLocalhost.name);
        }
    }
    let commandFlags = '';
    await inquirer_1.default
        .prompt([
        {
            type: 'list',
            name: 'network',
            message: 'Select a network',
            choices: activatedChainList
        }
    ])
        .then(async (networkSelected) => {
        ActivatedChainList.map((chain) => {
            if (chain.name === networkSelected.network)
                commandFlags = ' --network ' + chain.chainName;
        });
        if (GetAccountBalance)
            await GetAccountBalance(env);
        else if (ServeEnvBuilder)
            await ServeEnvBuilder(env, networkSelected.network);
        await (0, utils_1.sleep)(5000);
    });
    if (command)
        await (0, utils_1.runCommand)(command, firstCommand, commandFlags, true);
};
const serveTestSelector = async (env, command, firstCommand) => {
    const testFilesObject = await (0, buildFilesList_1.buildTestsList)();
    let testFilesList = [];
    if (testFilesObject !== undefined && testFilesObject.length > 0) {
        testFilesList = testFilesObject.map((file) => {
            return file.name;
        });
        if (testFilesList.length > 0) {
            await inquirer_1.default
                .prompt([
                {
                    type: 'list',
                    name: 'test',
                    message: 'Select a test',
                    choices: testFilesList
                }
            ])
                .then(async (testSelected) => {
                testFilesObject.forEach((file) => {
                    if (file.name === testSelected.test) {
                        if (file.type === 'file')
                            command = command + ' test/' + file.filePath;
                    }
                });
                if (firstCommand)
                    command = 'npx hardhat test ' + command;
                await serveNetworkSelector(env, command, firstCommand, '', '', false);
                await (0, utils_1.sleep)(5000);
            });
        }
    }
};
const serveScriptSelector = async (env, ServeTestSelector) => {
    const scriptFilesObject = await (0, buildFilesList_1.buildScriptsList)();
    const scriptFilesList = [];
    if (scriptFilesObject) {
        scriptFilesObject.map((file) => {
            scriptFilesList.push(file.name);
        });
        if (scriptFilesObject.length > 0) {
            await inquirer_1.default
                .prompt([
                {
                    type: 'list',
                    name: 'script',
                    message: 'Select a script',
                    choices: scriptFilesList
                }
            ])
                .then(async (scriptSelected) => {
                let command = 'npx hardhat run';
                scriptFilesObject.forEach((file) => {
                    if (file.name === scriptSelected.script) {
                        if (file.type === 'file')
                            command = command + ' scripts/' + file.filePath;
                    }
                });
                if (ServeTestSelector)
                    await ServeTestSelector(env, '', command);
                else {
                    await serveNetworkSelector(env, command, '', '', '', false);
                    await (0, utils_1.sleep)(5000);
                }
            });
        }
    }
};
const serveFlattenContractsSelector = async (env, command) => {
    const contractsFilesObject = await (0, buildFilesList_1.buildContractsList)();
    const contractsFilesList = ['Flatten all contracts'];
    const addressBookConfig = (0, config_1.getAddressBookConfig)(env.userConfig);
    let renameLicenseIdentifier = false;
    if (contractsFilesObject) {
        contractsFilesObject.map((file) => {
            contractsFilesList.push(file.name);
        });
        if (contractsFilesList.length > 0) {
            let contractFlattenName = '';
            await inquirer_1.default
                .prompt([
                {
                    type: 'list',
                    name: 'flatten',
                    message: 'Select a contract to flatten',
                    choices: contractsFilesList
                },
                {
                    type: 'confirm',
                    name: 'renameLicenseIdentifier',
                    message: 'Rename SPDX-License-Identifier'
                }
            ])
                .then(async (contractsSelected) => {
                renameLicenseIdentifier = contractsSelected.renameLicenseIdentifier;
                if (!fs_1.default.existsSync(addressBookConfig.contractsFlattenPath))
                    fs_1.default.mkdirSync(addressBookConfig.contractsFlattenPath);
                if (contractsSelected.flatten !== 'Flatten all contracts') {
                    contractsFilesObject.forEach((file) => {
                        if (file.name === contractsSelected.flatten) {
                            if (file.type === 'file') {
                                command = command + ' contracts/' + file.filePath;
                                contractFlattenName = addressBookConfig.contractsFlattenPrefix + file.filePath;
                            }
                        }
                    });
                }
                else
                    contractFlattenName = addressBookConfig.contractsFlattenPrefix + 'All.sol';
            });
            if (command) {
                await (0, utils_1.runCommand)(command, '', ' > ' + addressBookConfig.contractsFlattenPath + '/' + contractFlattenName, renameLicenseIdentifier ? false : true);
                await (0, utils_1.sleep)(3000);
                if (renameLicenseIdentifier) {
                    while (fs_1.default.readFileSync(addressBookConfig.contractsFlattenPath + '/' + contractFlattenName, 'utf8')
                        .length === 0) {
                        await (0, utils_1.sleep)(1000);
                    }
                    if (fs_1.default.readFileSync(addressBookConfig.contractsFlattenPath + '/' + contractFlattenName, 'utf8')
                        .length > 0) {
                        let fileContent = fs_1.default.readFileSync(addressBookConfig.contractsFlattenPath + '/' + contractFlattenName, 'utf8');
                        if (fileContent.includes('SPDX-License-Identifier')) {
                            fileContent = fileContent.replace('SPDX-License-Identifier', 'SPDX-License-DISABLED-Identifier');
                            fs_1.default.writeFileSync(addressBookConfig.contractsFlattenPath + '/' + contractFlattenName, fileContent);
                        }
                        else
                            console.log('SPDX-License-Identifier not found in ' + contractFlattenName + ' file, skipping rename');
                        if (fileContent.includes('pragma solidity')) {
                            fileContent = fileContent.replace('pragma solidity', '// pragma solidity');
                            fs_1.default.writeFileSync(addressBookConfig.contractsFlattenPath + '/' + contractFlattenName, fileContent);
                        }
                        else
                            console.log('pragma solidity not found in ' + contractFlattenName + ' file, skipping rename');
                    }
                }
            }
        }
    }
};
const serveFunctionListSelector = async (env) => {
    const contractsFilesObject = await (0, buildFilesList_1.buildContractsList)();
    const contractsFilesList = [];
    if (contractsFilesObject) {
        contractsFilesObject.map((file) => contractsFilesList.push(file.name));
        if (contractsFilesList.length > 0)
            await inquirer_1.default
                .prompt([
                {
                    type: 'list',
                    name: 'contractName',
                    message: 'Select a contract to list all functions',
                    choices: contractsFilesList
                }
            ])
                .then(async (contractsSelected) => {
                const functions = await (0, utils_1.listAllFunctionSelectors)(env, contractsSelected.contractName);
                console.log('Contract: ', '\x1b[32m', contractsSelected.contractName, '\x1b[0m', 'has ', '\x1b[32m', functions.length, '\x1b[0m', 'public and external functions, ordered by selector');
                console.table(functions);
                await (0, utils_1.sleep)(5000);
            });
    }
};
const serveFoundryTestSelector = async (env, command) => {
    const testFilesObject = await (0, buildFilesList_1.buildAllForgeTestsList)();
    let testFilesList = [];
    if (testFilesObject) {
        testFilesList = testFilesObject.map((file) => {
            return file.name;
        });
        if (testFilesList.length > 0) {
            await inquirer_1.default
                .prompt([
                {
                    type: 'list',
                    name: 'test',
                    message: 'Select a forge test',
                    choices: testFilesList
                }
            ])
                .then(async (testSelected) => {
                testFilesObject.forEach((file) => {
                    if (file.name === testSelected.test) {
                        if (file.type === 'file') {
                            command = command + ' --match-path contracts/test/' + file.filePath;
                        }
                    }
                });
                await (0, utils_1.runCommand)(command, '', '', true);
                await (0, utils_1.sleep)(5000);
            });
        }
    }
};
const serveEnvBuilder = async (env, chainSelected) => {
    const ActivatedChainList = await (0, buildFilesList_1.buildActivatedChainList)();
    if (ActivatedChainList.find((chain) => chain.name === chainSelected)) {
        const selectedChain = ActivatedChainList.find((chain) => chain.name === chainSelected);
        const defaultRpcUrl = await (0, buildEnv_1.getEnvValue)('rpcUrl'.toUpperCase() + '_' + selectedChain.chainName.toUpperCase());
        const defaultPrivateKey = await (0, buildEnv_1.getEnvValue)('privateKey'.toUpperCase() + '_' + selectedChain.chainName.toUpperCase());
        const defaultMnemonic = await (0, buildEnv_1.getEnvValue)('mnemonic'.toUpperCase() + '_' + selectedChain.chainName.toUpperCase());
        await inquirer_1.default
            .prompt([
            {
                type: 'input',
                name: 'rpcUrl',
                message: selectedChain.name + ' RPC Url',
                default: defaultRpcUrl
            },
            {
                type: 'input',
                name: 'privateKeyOrMnemonic',
                message: selectedChain.name + ' private key or mnemonic',
                default: defaultPrivateKey || defaultMnemonic
            }
        ])
            .then(async (envToBuild) => {
            await (0, buildEnv_1.default)(env, selectedChain.chainName, envToBuild);
        });
        await (0, utils_1.sleep)(2000);
    }
};
const serveSettingSelector = async (env) => {
    await inquirer_1.default
        .prompt([
        {
            type: 'list',
            name: 'settings',
            message: 'Select a setting',
            choices: [
                'Add/Remove chains from the chain selection',
                'Set RPC Url, private key or mnemonic for all or one chain',
                'Add a custom chain to the current chain selection',
                new inquirer_1.default.Separator(),
                'See all config for activated chain'
            ]
        }
    ])
        .then(async (settingSelected) => {
        const ActivatedChainList = await (0, buildFilesList_1.buildActivatedChainList)();
        const activatedChainList = [];
        ActivatedChainList.map((chain) => {
            activatedChainList.push(chain.name);
        });
        const FullChainList = config_1.DefaultChainList;
        const fullChainList = [];
        FullChainList.map((chain) => {
            fullChainList.push(chain.name);
        });
        if (settingSelected.settings === 'Add/Remove chains from the chain selection') {
            await inquirer_1.default
                .prompt([
                {
                    type: 'checkbox',
                    name: 'chainList',
                    message: 'Select a setting',
                    choices: fullChainList,
                    default: activatedChainList
                }
            ])
                .then(async (chainListSelected) => {
                fullChainList.map(async (chain) => {
                    if (chainListSelected.chainList.includes(chain)) {
                        await (0, buildNetworks_1.addActivatedChain)(chain);
                    }
                    else {
                        await (0, buildNetworks_1.removeActivatedChain)(chain);
                    }
                });
                console.log('\x1b[32m%s\x1b[0m', 'Settings updated!');
                await (0, utils_1.sleep)(1000);
            });
        }
        if (settingSelected.settings === 'Set RPC Url, private key or mnemonic for all or one chain')
            await serveNetworkSelector(env, '', '', '', serveEnvBuilder, true);
        if (settingSelected.settings === 'Add a custom chain to the current chain selection') {
            await inquirer_1.default
                .prompt([
                {
                    type: 'input',
                    name: 'name',
                    message: 'Chain Name'
                },
                {
                    type: 'input',
                    name: 'chainId',
                    message: 'Chain Id'
                },
                {
                    type: 'input',
                    name: 'gas',
                    message: 'Chain gas setting',
                    default: 'auto'
                },
                {
                    type: 'input',
                    name: 'defaultRpcUrl',
                    message: 'Chain default RPC Url'
                }
            ])
                .then(async (chainSelected) => {
                const getNetworkConfig = (0, buildNetworks_1.buildActivatedChainNetworkConfig)();
                let buildNetworkConfig = {};
                if (getNetworkConfig) {
                    buildNetworkConfig = `{
                                    "networks": [
                                        {${getNetworkConfig}}
                                    ]
                                }`;
                    buildNetworkConfig = JSON.parse(buildNetworkConfig);
                }
                let chainName = '';
                if (buildNetworkConfig.networks[0].customChain1 !== undefined && !chainName)
                    chainName = 'customChain1';
                if (buildNetworkConfig.networks[0].customChain2 !== undefined && !chainName)
                    chainName = 'customChain2';
                if (buildNetworkConfig.networks[0].customChain3 !== undefined && !chainName)
                    chainName = 'customChain3';
                if (buildNetworkConfig.networks[0].customChain4 !== undefined && !chainName)
                    chainName = 'customChain4';
                if (buildNetworkConfig.networks[0].customChain5 !== undefined && !chainName)
                    chainName = 'customChain5';
                if (buildNetworkConfig.networks[0].customChain6 !== undefined && !chainName)
                    chainName = 'customChain6';
                if (buildNetworkConfig.networks[0].customChain7 !== undefined && !chainName)
                    chainName = 'customChain7';
                if (buildNetworkConfig.networks[0].customChain8 !== undefined && !chainName)
                    chainName = 'customChain8';
                if (chainName) {
                    const chainToAdd = {
                        name: chainSelected.name,
                        chainName,
                        chainId: chainSelected.chainId,
                        gas: chainSelected.gas,
                        defaultRpcUrl: chainSelected.defaultRpcUrl
                    };
                    await (0, buildNetworks_1.addCustomChain)(chainToAdd);
                }
            });
        }
        if (settingSelected.settings === 'See all config for activated chain') {
            const getNetworkConfig = (0, buildNetworks_1.buildActivatedChainNetworkConfig)();
            let buildNetworkConfig = {};
            if (getNetworkConfig) {
                buildNetworkConfig = `{
                            "networks": [
                                {${getNetworkConfig}}
                            ]
                        }`;
                buildNetworkConfig = JSON.parse(buildNetworkConfig);
            }
            console.table(buildNetworkConfig.networks[0]);
        }
    });
};
const serveExcludeFileSelector = async (option) => {
    let allFiles = [];
    let excludedFiles = await (0, buildExcludedFile_1.buildExcludedFile)();
    const allFilesSelection = [];
    let allExcludedSelection = [];
    if (option === 'test')
        allFiles = await (0, buildFilesList_1.buildAllTestsList)();
    else if (option === 'scripts')
        allFiles = await (0, buildFilesList_1.buildAllScriptsList)();
    else if (option === 'contracts')
        allFiles = await (0, buildFilesList_1.buildAllContractsList)();
    if (allFiles && allFiles.length > 0) {
        if (allFiles.filter((test) => test.type === 'file').length > 0) {
            allFiles
                .filter((test) => test.type === 'file')
                .map((file) => {
                allFilesSelection.push(file.filePath);
            });
        }
    }
    if (excludedFiles && excludedFiles.length > 0) {
        excludedFiles = excludedFiles.filter((test) => test.directory === option);
        if (excludedFiles && excludedFiles.length > 0) {
            allExcludedSelection = excludedFiles.map((file) => {
                return file.filePath;
            });
        }
    }
    await inquirer_1.default
        .prompt([
        {
            type: 'checkbox',
            name: 'allFiles',
            message: 'Select the files you want to exclude',
            choices: allFilesSelection,
            default: allExcludedSelection
        }
    ])
        .then(async (activateFilesSelected) => {
        allFiles.map(async (file) => {
            if (activateFilesSelected.allFiles.includes(file.filePath))
                await (0, buildExcludedFile_1.addExcludedFiles)(option, file.name, file.filePath);
            else
                await (0, buildExcludedFile_1.removeExcludedFiles)(option, file.name);
        });
        console.log('\x1b[32m%s\x1b[0m', 'Settings updated!');
    });
};
const serveWorkflowBuilder = async () => {
    const workflowsList = [];
    let workflowToAdd;
    config_1.DefaultGithubWorkflowsGroup.map((workflowGroup) => {
        config_1.DefaultGithubWorkflowsList.filter((workflow) => workflow.group === workflowGroup).map((workflow) => {
            workflowsList.push(workflow.title);
        });
    });
    await inquirer_1.default
        .prompt([
        {
            type: 'list',
            name: 'workflowType',
            message: 'Select a workflow to create',
            choices: workflowsList
        }
    ])
        .then(async (workflowSelected) => {
        config_1.DefaultGithubWorkflowsList.map(async (workflow) => {
            if (workflow.title === workflowSelected.workflowType)
                workflowToAdd = workflow;
        });
    });
    if (workflowToAdd !== undefined) {
        await (0, buildWorkflows_1.default)(workflowToAdd);
        await (0, utils_1.sleep)(2000);
    }
};
const serveMoreSettingSelector = async (env) => {
    await inquirer_1.default
        .prompt([
        {
            type: 'list',
            name: 'moreSettings',
            message: 'Select a mock contract',
            choices: [
                'Exclude test file from the tests selection list',
                'Exclude script file from the scripts selection list',
                'Exclude contract file from the contract selection list',
                new inquirer_1.default.Separator(),
                'List function from a contract by function selector',
                new inquirer_1.default.Separator(),
                'Add other Hardhat plugins',
                'Remove other Hardhat plugins',
                new inquirer_1.default.Separator(),
                'Create Github test workflows',
                'Create Foundry settings, remapping and test utilities',
                new inquirer_1.default.Separator()
            ]
        }
    ])
        .then(async (moreSettingsSelected) => {
        if (moreSettingsSelected.moreSettings === 'Exclude test file from the tests selection list')
            await serveExcludeFileSelector('test');
        if (moreSettingsSelected.moreSettings === 'Exclude script file from the scripts selection list')
            await serveExcludeFileSelector('scripts');
        if (moreSettingsSelected.moreSettings === 'Exclude contract file from the contract selection list')
            await serveExcludeFileSelector('contracts');
        if (moreSettingsSelected.moreSettings === 'List function from a contract by function selector')
            await serveFunctionListSelector(env);
        if (moreSettingsSelected.moreSettings === 'Add other Hardhat plugins')
            await servePackageInstaller();
        if (moreSettingsSelected.moreSettings === 'Remove other Hardhat plugins')
            await servePackageUninstaller();
        if (moreSettingsSelected.moreSettings === 'Create Github test workflows')
            await serveWorkflowBuilder();
        if (moreSettingsSelected.moreSettings === 'Create Foundry settings, remapping and test utilities')
            await (0, buildFoundrySetting_1.default)();
    });
};
const servePackageInstaller = async () => {
    const hardhatPluginAvailableList = config_1.DefaultHardhatPluginsList.map((plugin) => {
        return plugin.title;
    });
    const hardhatPluginInstalled = [];
    config_1.DefaultHardhatPluginsList.map(async (plugin) => {
        if (await (0, packageInstaller_1.default)(plugin.name, false, false, false)) {
            hardhatPluginInstalled.push(plugin.title);
        }
    });
    await (0, utils_1.sleep)(500);
    const hardhatPluginToNotInclude = new Set(hardhatPluginInstalled);
    const hardhatPluginToInstall = hardhatPluginAvailableList.filter((plugin) => !hardhatPluginToNotInclude.has(plugin));
    let packageToInstall;
    await inquirer_1.default
        .prompt([
        {
            type: 'list',
            name: 'plugins',
            message: 'Select a plugin to install',
            choices: hardhatPluginToInstall
        }
    ])
        .then(async (pluginssSelected) => {
        config_1.DefaultHardhatPluginsList.map(async (plugin) => {
            if (plugin.title === pluginssSelected.plugins)
                packageToInstall = plugin;
        });
        await (0, utils_1.sleep)(1500);
    });
    if (packageToInstall !== undefined) {
        await (0, packageInstaller_1.default)(packageToInstall.name, true, false, packageToInstall.addInHardhatConfig);
        await (0, utils_1.sleep)(5000);
    }
};
const servePackageUninstaller = async () => {
    const hardhatPluginInstalled = [];
    config_1.DefaultHardhatPluginsList.map(async (plugin) => {
        if (await (0, packageInstaller_1.default)(plugin.name, false, false, false)) {
            hardhatPluginInstalled.push(plugin.title);
        }
    });
    await (0, utils_1.sleep)(1000);
    let packageToUninstall;
    await inquirer_1.default
        .prompt([
        {
            type: 'list',
            name: 'plugins',
            message: 'Select a plugin to install',
            choices: hardhatPluginInstalled
        }
    ])
        .then(async (pluginssSelected) => {
        config_1.DefaultHardhatPluginsList.map(async (plugin) => {
            if (plugin.title === pluginssSelected.plugins)
                packageToUninstall = plugin;
        });
        await (0, utils_1.sleep)(1500);
    });
    if (packageToUninstall !== undefined)
        await (0, packageInstaller_1.default)(packageToUninstall.name, false, true, packageToUninstall.addInHardhatConfig);
    await (0, utils_1.sleep)(5000);
};
const serveMockContractCreatorSelector = async () => {
    if (mockContracts_1.default) {
        const mockContractsList = mockContracts_1.default.map((file) => {
            return file.name;
        });
        let mockContractFirstSelected = '';
        let mockContractToAdd;
        await inquirer_1.default
            .prompt([
            {
                type: 'list',
                name: 'mockContract',
                message: 'Select a mock contract',
                choices: mockContractsList
            }
        ])
            .then(async (mockContractSelected) => {
            mockContractFirstSelected = mockContractSelected.mockContract;
        });
        if (mockContractFirstSelected) {
            const mockContractFirstSelectedDetail = mockContracts_1.default.filter((file) => file.name === mockContractFirstSelected)[0];
            const mockContractDetailSelector = [];
            if (mockContractFirstSelectedDetail.deploymentScriptJs !== undefined ||
                mockContractFirstSelectedDetail.deploymentScriptTs !== undefined)
                mockContractDetailSelector.push({
                    type: 'list',
                    name: 'mockDeploymentScript',
                    message: 'Create a deployment script for this mock contract',
                    choices: ['yes', 'no']
                });
            if (mockContractFirstSelectedDetail.testScriptJs !== undefined ||
                mockContractFirstSelectedDetail.testScriptTs !== undefined)
                mockContractDetailSelector.push({
                    type: 'list',
                    name: 'mockTestScript',
                    message: 'Create a test script for this mock contract',
                    choices: ['yes', 'no']
                });
            if (mockContractFirstSelectedDetail.testContractFoundry !== undefined &&
                fs_1.default.existsSync('contracts/test') &&
                fs_1.default.existsSync('foundry.toml'))
                mockContractDetailSelector.push({
                    type: 'list',
                    name: 'mockTestContractFoundry',
                    message: 'Create a Foundry test contract for this mock contract',
                    choices: ['yes', 'no']
                });
            await inquirer_1.default
                .prompt(mockContractDetailSelector)
                .then(async (mockContractSelected) => {
                mockContractToAdd = {
                    mockContract: mockContractFirstSelected,
                    mockDeploymentScript: mockContractSelected.mockDeploymentScript || 'no',
                    mockTestScript: mockContractSelected.mockTestScript || 'no',
                    mockTestContractFoundry: mockContractSelected.mockTestContractFoundry || 'no'
                };
            });
        }
        if (mockContractToAdd !== undefined) {
            await (0, buildMockContracts_1.default)(mockContractToAdd.mockContract);
            if (mockContractToAdd.mockDeploymentScript === 'yes')
                await (0, buildMockContracts_1.buildMockDeploymentScriptOrTest)(mockContractToAdd.mockContract, 'deployment');
            if (mockContractToAdd.mockTestScript === 'yes')
                await (0, buildMockContracts_1.buildMockDeploymentScriptOrTest)(mockContractToAdd.mockContract, 'test');
            if (mockContractToAdd.mockTestContractFoundry === 'yes')
                await (0, buildMockContracts_1.buildMockDeploymentScriptOrTest)(mockContractToAdd.mockContract, 'testForge');
        }
    }
};
const serveDeploymentContractCreatorSelector = async () => { };
const serveAccountBalance = async (env) => {
    const getAccountBalance = async (Env) => {
        const [deployer] = await Env.ethers.getSigners();
        const network = await Env.network;
        // Get account balance
        const balance = await deployer.getBalance();
        console.log('\x1b[32m%s\x1b[0m', 'Connected to network: ', '\x1b[97m%s\x1b[0m', network.name);
        console.log('\x1b[32m%s\x1b[0m', 'Account address: ', '\x1b[97m%s\x1b[0m', deployer.address);
        console.log('\x1b[32m%s\x1b[0m', 'Account balance: ', '\x1b[97m%s\x1b[0m', balance.toString());
    };
    await serveNetworkSelector(env, '', '', getAccountBalance, '', false);
};
const serveInquirer = async (env) => {
    console.log(`
`, '\x1b[34m', 'Welcome to', '\x1b[32m', `
 .d8b.  db   d8b   db d88888b .d8888.  .d88b.  .88b  d88. d88888b      .o88b. db      d888888b 
d8' '8b 88   I8I   88 88'     88'  YP .8P  Y8. 88'YbdP'88 88'         d8P  Y8 88        '88'   
88ooo88 88   I8I   88 88ooooo '8bo.   88    88 88  88  88 88ooooo     8P      88         88    
88~~~88 Y8   I8I   88 88~~~~~   'Y8b. 88    88 88  88  88 88~~~~~     8b      88         88    
88   88 '8b d8'8b d8' 88.     db   8D '8b  d8' 88  88  88 88.         Y8b  d8 88booo.   .88.   
YP   YP  '8b8' '8d8'  Y88888P '8888Y'  'Y88P'  YP  YP  YP Y88888P      'Y88P' Y88888P Y888888P 
`);
    const buildMainOptions = [utils_1.inquirerRunTests, utils_1.inquirerRunScripts, utils_1.inquirerFlattenContracts];
    if (utils_1.inquirerRunFoundryTest)
        buildMainOptions.push(utils_1.inquirerRunFoundryTest);
    if (utils_1.inquirerRunTests.name === 'Run tests' && utils_1.inquirerRunScripts.name === 'Run scripts')
        buildMainOptions.push('Select scripts and tests to run');
    const solidityCoverageDetected = await (0, packageInstaller_1.default)('solidity-coverage', false, false, false);
    if (solidityCoverageDetected)
        buildMainOptions.push('Run coverage tests');
    buildMainOptions.push('Setup chains, RPC and accounts', 'More settings', new inquirer_1.default.Separator(), 
    // 'Deploy all contracts and run tests',
    utils_1.inquirerRunMockContractCreator, 
    // 'Create deployment scripts',
    'Get account balance', new inquirer_1.default.Separator(), utils_1.inquirerFileContractsAddressDeployed, utils_1.inquirerFileContractsAddressDeployedHistory, new inquirer_1.default.Separator());
    await inquirer_1.default
        .prompt([
        {
            type: 'list',
            name: 'action',
            message: 'What do you want to do?',
            choices: buildMainOptions
        }
    ])
        .then(async (answers) => {
        if (answers.action === 'Run tests')
            await serveTestSelector(env, 'npx hardhat test', '');
        if (answers.action === 'Run scripts')
            await serveScriptSelector(env, '');
        if (answers.action === 'Flatten contracts')
            await serveFlattenContractsSelector(env, 'npx hardhat flatten');
        if (answers.action === 'Run Foundry Forge tests')
            await serveFoundryTestSelector(env, 'forge test');
        if (answers.action === 'Select scripts and tests to run')
            await serveScriptSelector(env, serveTestSelector);
        if (answers.action === 'Run coverage tests')
            await serveTestSelector(env, 'npx hardhat coverage', '');
        if (answers.action === 'Setup chains, RPC and accounts')
            await serveSettingSelector(env);
        if (answers.action === 'More settings')
            await serveMoreSettingSelector(env);
        if (answers.action === 'Create Mock contracts')
            await serveMockContractCreatorSelector();
        if (answers.action === 'Create deployment scripts')
            await serveDeploymentContractCreatorSelector();
        if (answers.action === 'Get account balance')
            await serveAccountBalance(env);
    });
};
const serveCli = async (args, env) => {
    switch (true) {
        case args.excludeTestFile !== '':
            return (0, buildExcludedFile_1.removeExcludedFiles)('test', args.excludeTestFile);
        case args.excludeScriptFile !== '':
            return (0, buildExcludedFile_1.removeExcludedFiles)('scripts', args.excludeScriptFile);
        case args.excludeContractFile !== '':
            return (0, buildExcludedFile_1.removeExcludedFiles)('contracts', args.excludeContractFile);
        case args.addHardhatPlugin !== '':
            return (0, packageInstaller_1.default)(args.addHardhatPlugin, true, false, true);
        case args.removeHardhatPlugin !== '':
            return (0, packageInstaller_1.default)(args.removeHardhatPlugin, false, true, true);
        case args.addGithubTestWorkflow !== '':
            return (0, buildWorkflows_1.buildWorkflowsFromCommand)(args.addGithubTestWorkflow);
        case args.addFoundry === true || args.addFoundry === 'true' || args.addFoundry === 'yes':
            return (0, buildFoundrySetting_1.default)();
        case args.addActivatedChain !== '':
            return (0, buildNetworks_1.addActivatedChain)(args.addActivatedChain);
        case args.removeActivatedChain !== '':
            return (0, buildNetworks_1.removeActivatedChain)(args.removeActivatedChain);
        case args.getAccountBalance === true || args.getAccountBalance === 'true' || args.getAccountBalance === 'yes':
            return serveAccountBalance(env);
        default:
            return serveInquirer(env);
    }
};
exports.default = serveCli;
//# sourceMappingURL=serveInquirer.js.map