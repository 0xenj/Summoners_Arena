"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnvValue = void 0;
const fs_1 = __importDefault(require("fs"));
const config_1 = require("./config");
const addEnvFileInGitiignore = async (ignoreFile, envFile, createIfNotExist) => {
    if (fs_1.default.existsSync(ignoreFile)) {
        const rawdata = fs_1.default.readFileSync(ignoreFile);
        const gitignore = rawdata.toString();
        if (!gitignore.includes(envFile)) {
            console.log('\x1b[33m%s\x1b[0m', 'Adding ' + envFile + ' to your ' + ignoreFile + ' file');
            const newGitignore = rawdata + '\n\n#Hardhat-Awesome-CLI\n' + envFile;
            fs_1.default.writeFileSync(ignoreFile, newGitignore);
        }
    }
    else {
        if (createIfNotExist) {
            const newGitignore = '\n\n#Hardhat-Awesome-CLI\n' + envFile;
            fs_1.default.writeFileSync(ignoreFile, newGitignore);
            console.log('\x1b[33m%s\x1b[0m', 'Adding ' + envFile + ' to your ' + ignoreFile + ' file');
        }
    }
};
const getEnvValue = (envName) => {
    const addressBookConfig = (0, config_1.getAddressBookConfig)();
    if (fs_1.default.existsSync(addressBookConfig.fileEnvHardhatAwesomeCLI)) {
        const allEnv = require('dotenv').config({ path: addressBookConfig.fileEnvHardhatAwesomeCLI });
        const oldEnv = Object.entries(allEnv.parsed);
        for (const [key, value] of oldEnv) {
            if (key && value && key === envName)
                return exports.getEnvValue;
        }
    }
    return '';
};
exports.getEnvValue = getEnvValue;
const writeToEnv = async (env, chainName, envToBuild) => {
    const addressBookConfig = (0, config_1.getAddressBookConfig)(env.userConfig);
    let isRpcUrl = false;
    let isPrivateKey = false;
    let isMnemonic = false;
    const rpcUrlEnv = 'rpcUrl'.toUpperCase() + '_' + chainName.toUpperCase() + ' = ' + '"' + envToBuild.rpcUrl + '"';
    const privateKeyEnv = 'privateKey'.toUpperCase() + '_' + chainName.toUpperCase() + ' = ' + '"' + envToBuild.privateKeyOrMnemonic + '"';
    const mnemonicEnv = 'mnemonic'.toUpperCase() + '_' + chainName.toUpperCase() + ' = ' + '"' + envToBuild.privateKeyOrMnemonic + '"';
    if (envToBuild.rpcUrl)
        isRpcUrl = true;
    if (envToBuild.privateKeyOrMnemonic) {
        try {
            const owner = new env.ethers.Wallet(envToBuild.privateKeyOrMnemonic, env.ethers.provider);
            isPrivateKey = true;
        }
        catch (_a) {
            try {
                const owner = await env.ethers.Wallet.fromMnemonic(envToBuild.privateKeyOrMnemonic);
                isMnemonic = true;
            }
            catch (_b) {
                console.log('\x1b[31m%s\x1b[0m', 'Error: Private Key or Mnemonic is not valid');
            }
            isPrivateKey = false;
        }
    }
    let envToWrite = '';
    if (isRpcUrl)
        envToWrite = rpcUrlEnv + '\n';
    if (isPrivateKey)
        envToWrite = privateKeyEnv + '\n';
    if (isMnemonic)
        envToWrite = mnemonicEnv + '\n';
    if (fs_1.default.existsSync(addressBookConfig.fileEnvHardhatAwesomeCLI)) {
        const allEnv = require('dotenv').config({ path: addressBookConfig.fileEnvHardhatAwesomeCLI });
        const oldEnv = Object.entries(allEnv.parsed);
        let newEnv = '';
        const wipEnv = [];
        let isRpcUrlEnvExist = false;
        let isPrivateKeyEnvExist = false;
        let isMnemoniclEnvExist = false;
        for (const [key, value] of oldEnv) {
            if (!wipEnv.find((eachEnv) => eachEnv.key === key)) {
                wipEnv.push({
                    key
                });
                if (key && value && isRpcUrl && key === 'rpcUrl'.toUpperCase() + '_' + chainName.toUpperCase()) {
                    newEnv += key + ' = "' + envToBuild.rpcUrl + '"\n';
                    isRpcUrlEnvExist = true;
                }
                else if (key &&
                    value &&
                    isPrivateKey &&
                    key === 'privateKey'.toUpperCase() + '_' + chainName.toUpperCase()) {
                    newEnv += key + ' = "' + envToBuild.privateKeyOrMnemonic + '"\n';
                    isPrivateKeyEnvExist = true;
                }
                else if (key &&
                    value &&
                    isMnemonic &&
                    key === 'mnemonic'.toUpperCase() + '_' + chainName.toUpperCase()) {
                    newEnv += key + ' = "' + envToBuild.privateKeyOrMnemonic + '"\n';
                    isMnemoniclEnvExist = true;
                }
                else
                    newEnv += key + ' = "' + value + '"\n';
            }
        }
        if (isRpcUrl && !isRpcUrlEnvExist)
            newEnv += rpcUrlEnv + '\n';
        if (isPrivateKey && !isPrivateKeyEnvExist)
            newEnv += privateKeyEnv + '\n';
        if (isMnemonic && !isMnemoniclEnvExist)
            newEnv += mnemonicEnv + '\n';
        fs_1.default.writeFileSync(addressBookConfig.fileEnvHardhatAwesomeCLI, newEnv);
    }
    else
        fs_1.default.writeFileSync(addressBookConfig.fileEnvHardhatAwesomeCLI, envToWrite);
    console.log('\x1b[32m%s\x1b[0m', 'Env file updated');
    await addEnvFileInGitiignore('.gitignore', addressBookConfig.fileEnvHardhatAwesomeCLI, true);
    await addEnvFileInGitiignore('.npmignore', addressBookConfig.fileEnvHardhatAwesomeCLI, false);
};
exports.default = writeToEnv;
//# sourceMappingURL=buildEnv.js.map