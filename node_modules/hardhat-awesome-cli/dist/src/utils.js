"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.listAllFunctionSelectors = exports.runCommand = exports.inquirerFileContractsAddressDeployedHistory = exports.inquirerFileContractsAddressDeployed = exports.inquirerRunFoundryTest = exports.inquirerRunMockContractCreator = exports.inquirerFlattenContracts = exports.inquirerRunScripts = exports.inquirerRunTests = void 0;
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const process_1 = require("process");
const config_1 = require("./config");
let contractsAddressDeployed = [];
let contractsAddressDeployedHistory = [];
const addressBookConfig = (0, config_1.getAddressBookConfig)();
exports.inquirerRunTests = { name: 'Run tests' };
if (!fs_1.default.existsSync('test'))
    exports.inquirerRunTests.disabled = "We can't run tests without a test/ directory";
exports.inquirerRunScripts = { name: 'Run scripts' };
if (!fs_1.default.existsSync('scripts'))
    exports.inquirerRunScripts.disabled = "We can't run scripts without a scripts/ directory";
exports.inquirerFlattenContracts = { name: 'Flatten contracts' };
exports.inquirerRunMockContractCreator = { name: 'Create Mock contracts' };
exports.inquirerRunFoundryTest = '';
if (!fs_1.default.existsSync('contracts')) {
    exports.inquirerFlattenContracts.disabled = "We can't flatten contracts without a contracts/ directory";
    exports.inquirerRunMockContractCreator.disabled = "We can't create Mock contracts without a contracts/ directory";
}
if (fs_1.default.existsSync('contracts/test') && fs_1.default.existsSync('foundry.toml')) {
    exports.inquirerRunFoundryTest = 'Run Foundry Forge tests';
}
exports.inquirerFileContractsAddressDeployed = {
    name: 'Get the previously deployed contracts address',
    disabled: 'Please deploy the contracts first'
};
if (fs_1.default.existsSync(addressBookConfig.savePath + addressBookConfig.fileContractsAddressDeployed)) {
    const rawdata = fs_1.default.readFileSync(addressBookConfig.savePath + addressBookConfig.fileContractsAddressDeployed);
    try {
        contractsAddressDeployed = JSON.parse(rawdata);
        exports.inquirerFileContractsAddressDeployed = 'Get the previously deployed contracts address';
    }
    catch (_a) { }
}
exports.inquirerFileContractsAddressDeployedHistory = {
    name: 'Get all the previously deployed contracts address',
    disabled: 'Please deploy the contracts first'
};
if (fs_1.default.existsSync(addressBookConfig.savePath + addressBookConfig.fileContractsAddressDeployedHistory)) {
    try {
        const rawdata = fs_1.default.readFileSync(addressBookConfig.savePath + addressBookConfig.fileContractsAddressDeployedHistory);
        contractsAddressDeployedHistory = JSON.parse(rawdata);
        exports.inquirerFileContractsAddressDeployedHistory = 'Get all the previously deployed contracts address';
    }
    catch (_b) { }
}
const runCommand = async (command, firstCommand, commandFlags, thenExit = true) => {
    let commandToRun = command + commandFlags;
    if (firstCommand) {
        commandToRun = firstCommand + commandFlags + ' && ' + commandToRun;
    }
    console.log('\x1b[33m%s\x1b[0m', 'Command to run: ', '\x1b[97m\x1b[0m', commandToRun);
    console.log(`Please wait...
`);
    const runSpawn = (0, child_process_1.spawn)(commandToRun, {
        stdio: 'inherit',
        shell: true
    });
    runSpawn.on('exit', (code) => {
        if (thenExit)
            (0, process_1.exit)();
    });
};
exports.runCommand = runCommand;
const listAllFunctionSelectors = async (hre, contractName) => {
    const factory = await hre.ethers.getContractFactory(contractName);
    const functions = [];
    for (const [name] of Object.entries(factory.interface.functions)) {
        functions.push({
            name,
            selector: hre.ethers.utils.id(name).substring(0, 10)
        });
    }
    functions.sort((a, b) => {
        return a.selector.localeCompare(b.selector);
    });
    return functions;
};
exports.listAllFunctionSelectors = listAllFunctionSelectors;
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
exports.sleep = sleep;
//# sourceMappingURL=utils.js.map